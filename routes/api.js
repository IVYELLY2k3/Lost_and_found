const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const { db } = require('../services/firebase'); // Now the local DB version
const { analyzeImage } = require('../services/vision');
const { v4: uuidv4 } = require('uuid');

// Multer setup (Disk storage for Local Mode)
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, 'public/uploads/')
    },
    filename: function (req, file, cb) {
        cb(null, Date.now() + path.extname(file.originalname)) // Append extension
    }
});

const upload = multer({ storage: storage });

// Helper: Extract valid tags from description (Basic NLP)
function extractTagsFromText(text) {
    if (!text) return [];
    const stopwords = ['the', 'a', 'an', 'is', 'in', 'on', 'at', 'of', 'lost', 'found', 'my', 'please'];
    return text.toLowerCase().split(/\W+/)
        .filter(w => w.length > 2 && !stopwords.includes(w));
}

// Helper to find matches with Weighted Scoring
async function findMatches(newItem, targetCollection) {
    const snapshot = await db.collection(targetCollection).get();
    const matches = [];

    if (!newItem.tags) newItem.tags = [];

    // Known color tags generated by our local vision service
    const colorKeywords = ['white', 'black', 'red', 'green', 'blue', 'yellow', 'colorful', 'grey', 'gray', 'purple', 'orange', 'brown', 'pink'];

    snapshot.forEach(doc => {
        const item = doc.data();

        // Find intersection
        const commonTags = item.tags.filter(tag => newItem.tags.includes(tag));

        if (commonTags.length === 0) return;

        // Calculate Score
        let score = 0;
        let contentMatchCount = 0;

        commonTags.forEach(tag => {
            if (colorKeywords.includes(tag)) {
                score += 1; // Low score for color match
            } else {
                score += 10; // High score for content/keyword match (e.g. "wallet", "keys")
                contentMatchCount++;
            }
        });

        // Filtering Rules:
        // 1. If we have a content match (score >= 10), it's a strong candidate.
        // 2. If we ONLY have color matches, we need at least 3 matching colors to consider it (very similar palette), 
        //    OR the user didn't provide any content tags so we are desperate.
        //    But generally, color-only matches are bad. Let's filter them out unless they are very strong.

        // Threshold:
        // - Show if Score >= 10 (At least one keyword match)
        // - OR if Score >= 3 AND commonTags.length >= 3 (Strong color overlap, fallback)

        if (score >= 10 || (score >= 2 && contentMatchCount === 0 && newItem.tags.length <= 3)) {
            // The second condition is a fallback: if the SEARCHED item has almost no tags (no description), 
            // we serve color matches. If it HAS description, we ignore color-only matches.

            // Better logic:
            const hasDescription = newItem.tags.some(t => !colorKeywords.includes(t));

            if (hasDescription && contentMatchCount === 0) {
                // User described something ("wallet") but we only matched on "black".
                // This is likely a FALSE POSITIVE. Skip it.
                return;
            }

            matches.push({ ...item, matchScore: score });
        }
    });

    return matches.sort((a, b) => b.matchScore - a.matchScore);
}

// POST /analyze (Pre-upload analysis)
router.post('/analyze', upload.single('image'), async (req, res) => {
    try {
        if (!req.file) return res.status(400).send('No image uploaded.');

        // Analyze
        const analysis = await analyzeImage(req.file.path);
        
        // Return analysis without saving to DB yet
        res.json({ success: true, analysis });

    } catch (error) {
        console.error('Analysis Error:', error);
        res.status(500).json({ error: 'Analysis failed' });
    }
});

// POST /lost
router.post('/lost', upload.single('image'), async (req, res) => {
    try {
        if (!req.file) return res.status(400).send('No image uploaded.');

        const { contactName, contactEmail, description, dateLost } = req.body;

        // 1. Analyze Image (Local)
        // For local analysis, we pass the local file path
        const analysis = await analyzeImage(req.file.path);

        // 2. Extract keywords from description
        const textTags = extractTagsFromText(description);
        const finalTags = [...new Set([...analysis.labels, ...textTags])];

        const imageUrl = `/uploads/${req.file.filename}`;

        const newItem = {
            type: 'lost',
            imageUrl,
            tags: finalTags,
            colors: analysis.colors,
            description,
            contactName,
            contactEmail,
            dateLost,
            timestamp: new Date().toISOString(),
            status: 'active'
        };

        // 3. Save to Local DB
        const docRef = await db.collection('lost_items').add(newItem);

        // 4. Find Matches
        const matches = await findMatches(newItem, 'found_items');

        res.json({ success: true, id: docRef.id, matches, item: newItem });

    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

// POST /found (Admin)
router.post('/found', upload.single('image'), async (req, res) => {
    try {
        if (!req.file) return res.status(400).send('No image uploaded.');

        const { locationFound, description, dateFound } = req.body;

        const analysis = await analyzeImage(req.file.path);
        const textTags = extractTagsFromText(description);
        const finalTags = [...new Set([...analysis.labels, ...textTags])];

        const imageUrl = `/uploads/${req.file.filename}`;

        const newItem = {
            type: 'found',
            imageUrl,
            tags: finalTags,
            colors: analysis.colors,
            description,
            locationFound,
            dateFound,
            timestamp: new Date().toISOString(),
            status: 'available'
        };

        const docRef = await db.collection('found_items').add(newItem);
        const matches = await findMatches(newItem, 'lost_items');

        res.json({ success: true, id: docRef.id, matches, item: newItem });

    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

// GET /lost
router.get('/lost', async (req, res) => {
    try {
        res.set('Cache-Control', 'no-store');
        const snapshot = await db.collection('lost_items').orderBy().get();
        // Our local mock .get() returns an array with .data() methods
        const items = snapshot.map(doc => ({ id: doc.id, ...doc.data() }));
        // Simple sort by timestamp desc
        items.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        res.json(items);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /found
router.get('/found', async (req, res) => {
    try {
        res.set('Cache-Control', 'no-store');
        const snapshot = await db.collection('found_items').orderBy().get();
        const items = snapshot.map(doc => ({ id: doc.id, ...doc.data() }));
        items.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        res.json(items);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// DELETE /items/:type/:id (Admin delete)
router.delete('/items/:type/:id', async (req, res) => {
    try {
        const { type, id } = req.params;
        // type is 'lost' or 'found' from the frontend call
        const collection = type === 'lost' ? 'lost_items' : 'found_items';
        await db.collection(collection).doc(id).delete();
        res.json({ success: true });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: error.message });
    }
});

// PUT /items/:type/:id/claim (Mark as found/claimed)
router.put('/items/:type/:id/claim', async (req, res) => {
    try {
        const { type, id } = req.params;
        const collection = type === 'lost' ? 'lost_items' : 'found_items';
        await db.collection(collection).doc(id).update({ status: 'claimed' });
        res.json({ success: true });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// POST /notify (User notifies admin of a match)
router.post('/notify', async (req, res) => {
    console.log('Received notification request:', req.body);
    try {
        const { lostId, foundId, message } = req.body;

        // Validation
        if (!lostId || !foundId) {
            console.error('Missing ID in notification');
            return res.status(400).json({ error: 'Missing item IDs' });
        }

        console.log('Saving notification to DB...');
        const docRef = await db.collection('notifications').add({
            type: 'match_claim',
            lostId,
            foundId,
            message,
            timestamp: new Date().toISOString(),
            status: 'unread'
        });
        console.log('Notification saved with ID:', docRef.id);

        res.json({ success: true });
    } catch (error) {
        console.error('Notification Error:', error);
        res.status(500).json({ error: error.message });
    }
});

// GET /notifications (Admin fetch)
router.get('/notifications', async (req, res) => {
    try {
        res.set('Cache-Control', 'no-store');
        const snapshot = await db.collection('notifications').orderBy().get();
        const items = snapshot.map(doc => ({ id: doc.id, ...doc.data() }));
        items.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        res.json(items);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

module.exports = router;
