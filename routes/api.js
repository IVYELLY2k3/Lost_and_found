const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
// NOTE: Must ensure 'uploadFile' is exported from services/firebase
const { db, uploadFile } = require('../services/firebase'); 
const { analyzeImage } = require('../services/vision');
const { v4: uuidv4 } = require('uuid');

// ------------------------------------------------------------------
// FIX 1: Use Multer Memory Storage for Cloud Deployment
// Files are stored in req.file.buffer, avoiding disk write.
// ------------------------------------------------------------------
const storage = multer.memoryStorage(); 

const upload = multer({ storage: storage });

// Helper: Extract valid tags from description (Basic NLP)
function extractTagsFromText(text) {
    if (!text) return [];
    const stopwords = ['the', 'a', 'an', 'is', 'in', 'on', 'at', 'of', 'lost', 'found', 'my', 'please'];
    return text.toLowerCase().split(/\W+/)
        .filter(w => w.length > 2 && !stopwords.includes(w));
}

// Helper to find matches with Weighted Scoring (No changes here)
async function findMatches(newItem, targetCollection) {
    const snapshot = await db.collection(targetCollection).get();
    const matches = [];

    if (!newItem.tags) newItem.tags = [];

    // Known color tags generated by our local vision service
    const colorKeywords = ['white', 'black', 'red', 'green', 'blue', 'yellow', 'colorful', 'grey', 'gray', 'purple', 'orange', 'brown', 'pink'];

    snapshot.forEach(doc => {
        const item = doc.data();

        // Find intersection
        const commonTags = item.tags.filter(tag => newItem.tags.includes(tag));

        if (commonTags.length === 0) return;

        // Calculate Score
        let score = 0;
        let contentMatchCount = 0;

        commonTags.forEach(tag => {
            if (colorKeywords.includes(tag)) {
                score += 1; // Low score for color match
            } else {
                score += 10; // High score for content/keyword match (e.g. "wallet", "keys")
                contentMatchCount++;
            }
        });

        if (score >= 10 || (score >= 2 && contentMatchCount === 0 && newItem.tags.length <= 3)) {
            const hasDescription = newItem.tags.some(t => !colorKeywords.includes(t));

            if (hasDescription && contentMatchCount === 0) {
                return;
            }

            matches.push({ ...item, matchScore: score });
        }
    });

    return matches.sort((a, b) => b.matchScore - a.matchScore);
}

// POST /analyze (Pre-upload analysis)
router.post('/analyze', upload.single('image'), async (req, res) => {
    try {
        if (!req.file) return res.status(400).send('No image uploaded.');

        // FIX 2: Pass file buffer instead of path to analysis function
        const analysis = await analyzeImage(req.file.buffer); 
        
        // Return analysis without saving to DB yet
        res.json({ success: true, analysis });

    } catch (error) {
        console.error('Analysis Error:', error);
        res.status(500).json({ error: 'Analysis failed' });
    }
});

// POST /lost
router.post('/lost', upload.single('image'), async (req, res) => {
    try {
        if (!req.file) return res.status(400).send('No image uploaded.');

        const { contactName, contactEmail, description, dateLost } = req.body;

        // 1. Analyze Image (using buffer)
        const analysis = await analyzeImage(req.file.buffer);

        // 2. Upload image to Firebase Storage and get the public URL
        const fileExtension = path.extname(req.file.originalname);
        const storagePath = `lost_items/${uuidv4()}${fileExtension}`; 
        const imageUrl = await uploadFile(req.file.buffer, storagePath, req.file.mimetype); // FIX 3: Use uploadFile

        // 3. Extract keywords from description
        const textTags = extractTagsFromText(description);
        const finalTags = [...new Set([...analysis.labels, ...textTags])];

        const newItem = {
            type: 'lost',
            imageUrl, // FIX 4: Save the public URL instead of local path
            tags: finalTags,
            colors: analysis.colors,
            description,
            contactName,
            contactEmail,
            dateLost,
            timestamp: new Date().toISOString(),
            status: 'active'
        };

        // 4. Save to DB
        const docRef = await db.collection('lost_items').add(newItem);

        // 5. Find Matches
        const matches = await findMatches(newItem, 'found_items');

        res.json({ success: true, id: docRef.id, matches, item: newItem });

    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

// POST /found (Admin)
router.post('/found', upload.single('image'), async (req, res) => {
    try {
        if (!req.file) return res.status(400).send('No image uploaded.');

        const { locationFound, description, dateFound } = req.body;

        // 1. Analyze Image (using buffer)
        const analysis = await analyzeImage(req.file.buffer);
        
        // 2. Upload image to Firebase Storage and get the public URL
        const fileExtension = path.extname(req.file.originalname);
        const storagePath = `found_items/${uuidv4()}${fileExtension}`;
        const imageUrl = await uploadFile(req.file.buffer, storagePath, req.file.mimetype); // FIX 3: Use uploadFile

        const textTags = extractTagsFromText(description);
        const finalTags = [...new Set([...analysis.labels, ...textTags])];

        const newItem = {
            type: 'found',
            imageUrl, // FIX 4: Save the public URL instead of local path
            tags: finalTags,
            colors: analysis.colors,
            description,
            locationFound,
            dateFound,
            timestamp: new Date().toISOString(),
            status: 'available'
        };

        const docRef = await db.collection('found_items').add(newItem);
        const matches = await findMatches(newItem, 'lost_items');

        res.json({ success: true, id: docRef.id, matches, item: newItem });

    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

// GET /lost (No changes)
router.get('/lost', async (req, res) => {
    try {
        res.set('Cache-Control', 'no-store');
        const snapshot = await db.collection('lost_items').orderBy().get();
        // Our local mock .get() returns an array with .data() methods
        const items = snapshot.map(doc => ({ id: doc.id, ...doc.data() }));
        // Simple sort by timestamp desc
        items.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        res.json(items);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /found (No changes)
router.get('/found', async (req, res) => {
    try {
        res.set('Cache-Control', 'no-store');
        const snapshot = await db.collection('found_items').orderBy().get();
        const items = snapshot.map(doc => ({ id: doc.id, ...doc.data() }));
        items.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        res.json(items);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// DELETE /items/:type/:id (Admin delete - No changes)
router.delete('/items/:type/:id', async (req, res) => {
    try {
        const { type, id } = req.params;
        // type is 'lost' or 'found' from the frontend call
        const collection = type === 'lost' ? 'lost_items' : 'found_items';
        await db.collection(collection).doc(id).delete();
        res.json({ success: true });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: error.message });
    }
});

// PUT /items/:type/:id/claim (Mark as found/claimed - No changes)
router.put('/items/:type/:id/claim', async (req, res) => {
    try {
        const { type, id } = req.params;
        const collection = type === 'lost' ? 'lost_items' : 'found_items';
        await db.collection(collection).doc(id).update({ status: 'claimed' });
        res.json({ success: true });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// POST /notify (No changes)
router.post('/notify', async (req, res) => {
    console.log('Received notification request:', req.body);
    try {
        const { lostId, foundId, message } = req.body;

        // Validation
        if (!lostId || !foundId) {
            console.error('Missing ID in notification');
            return res.status(400).json({ error: 'Missing item IDs' });
        }

        console.log('Saving notification to DB...');
        const docRef = await db.collection('notifications').add({
            type: 'match_claim',
            lostId,
            foundId,
            message,
            timestamp: new Date().toISOString(),
            status: 'unread'
        });
        console.log('Notification saved with ID:', docRef.id);

        res.json({ success: true });
    } catch (error) {
        console.error('Notification Error:', error);
        res.status(500).json({ error: error.message });
    }
});

// GET /notifications (Admin fetch - No changes)
router.get('/notifications', async (req, res) => {
    try {
        res.set('Cache-Control', 'no-store');
        const snapshot = await db.collection('notifications').orderBy().get();
        const items = snapshot.map(doc => ({ id: doc.id, ...doc.data() }));
        items.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        res.json(items);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

module.exports = router;
